/* eslint-disable @typescript-eslint/no-explicit-any */

import { fireEvent, render, screen, waitFor } from "@testing-library/react";
import { updateApplicationStatuses } from "../../../features/api/application";
import { ProgressStatus } from "../../../features/api/types";
import { waitForSubgraphSyncTo } from "../../../features/api/subgraph";
import { faker } from "@faker-js/faker";
import { BulkUpdateGrantApplicationProvider, useBulkUpdateGrantApplications } from "../BulkUpdateGrantApplicationContext";
import { makeApplication } from "../../../test-utils";
import { act } from "react-dom/test-utils";
jest.mock("../../../features/api/application");
jest.mock("../../../features/api/subgraph");
jest.mock("../../../features/common/Auth", () => ({
  useWallet: () => mockWallet,
}));
const mockWallet = {
  address: "0x0",
  signer: {
    getChainId: () => {
      /* do nothing.*/
    },
  },
};

jest.setTimeout(20000);

// temp fix for prod merge
describe("<BulkUpdateGrantApplicationProvider />", () => {
  it("placeholder", () => {
    expect(true).toBe(true);
  });
});

describe("<BulkUpdateGrantApplicationProvider />", () => {
  beforeEach(() => {
    jest.resetAllMocks();
  });

  describe("useBulkUpdateGrantApplication", () => {
    it("sets contract update status to in progress when contract is being updated", async () => {
      (updateApplicationStatuses as jest.Mock).mockReturnValue(
        new Promise(() => {
          /* do nothing.*/
        })
      );

      renderWithProvider(<TestUseBulkUpdateGrantApplicationComponent />);

      await act(async () => fireEvent.click(screen.getByTestId("update-grant-application")));

      await waitFor(() => {
        expect(
          screen.findByTestId(`contract-updating-status-is-${ProgressStatus.IN_PROGRESS}`)
        );
      }, { timeout: 15000 });
    });

    it("sets update status to complete when updating contract succeeds", async () => {
      (updateApplicationStatuses as jest.Mock).mockResolvedValue({
        transactionBlockNumber: 100,
      });
      renderWithProvider(<TestUseBulkUpdateGrantApplicationComponent />);

      await act(async () => fireEvent.click(screen.getByTestId("update-grant-application")));

      await waitFor(() => {
        expect(
          screen.findByTestId(`contract-updating-status-is-${ProgressStatus.IS_SUCCESS}`)
        );
      }, { timeout: 15000 });
    });

    it("sets indexing status to in progress when waiting for subgraph to index", async () => {
      const transactionBlockNumber = 10;
      (updateApplicationStatuses as jest.Mock).mockResolvedValue({
        transactionBlockNumber,
      });
      (waitForSubgraphSyncTo as jest.Mock).mockReturnValue(
        new Promise(() => {
          /* do nothing.*/
        })
      );

      renderWithProvider(<TestUseBulkUpdateGrantApplicationComponent />);

      const createContract = screen.getByTestId("update-grant-application");
      await act(async () => fireEvent.click(createContract));

      await waitFor(() => {
        expect(
          screen.findByTestId(`indexing-status-is-${ProgressStatus.IN_PROGRESS}`)
        );
      }, { timeout: 15000 });
    });

    it("sets indexing status to completed when subgraph is finished indexing", async () => {
      const transactionBlockNumber = faker.datatype.number();
      (updateApplicationStatuses as jest.Mock).mockResolvedValue({
        transactionBlockNumber,
      });
      (waitForSubgraphSyncTo as jest.Mock).mockResolvedValue({});

      renderWithProvider(<TestUseBulkUpdateGrantApplicationComponent />);

      const createContract = screen.getByTestId("update-grant-application");
      await act(async () => fireEvent.click(createContract));

      await waitFor(() => {
        expect(
          screen.findByTestId(`indexing-status-is-${ProgressStatus.IS_SUCCESS}`)
        );
      }, { timeout: 15000 });
    });

    describe("useBulkUpdateGrantApplication Errors", () => {
      let consoleErrorSpy: jest.SpyInstance;

      beforeEach(() => {
        consoleErrorSpy = jest
          .spyOn(console, "error")
          .mockImplementation(() => {
            /* do nothing.*/
          });
      });

      afterEach(() => {
        consoleErrorSpy.mockClear();
      });

      it("sets indexing status to error when waiting for subgraph to sync fails", async () => {
        (updateApplicationStatuses as jest.Mock).mockResolvedValue({
          transactionBlockNumber: 100,
        });
        (waitForSubgraphSyncTo as jest.Mock).mockRejectedValue(new Error(":("));

        renderWithProvider(<TestUseBulkUpdateGrantApplicationComponent />);
        await act(async () =>
          fireEvent.click(screen.getByTestId("update-grant-application")));

        await waitFor(() => {
          expect(
            screen.getByTestId(`indexing-status-is-${ProgressStatus.IS_ERROR}`)
          ).toBeInTheDocument();
        }, { timeout: 15000 });
      });

      it("if contract update fails, resets contract updating status when bulk update is retried", async () => {
        (updateApplicationStatuses as jest.Mock)
          .mockRejectedValueOnce(new Error(":("))
          .mockReturnValue(
            new Promise(() => {
              /* do nothing.*/
            })
          );

        renderWithProvider(<TestUseBulkUpdateGrantApplicationComponent />);
        await act(async () => fireEvent.click(screen.getByTestId("update-grant-application")));

        // retry bulk update operation
        await waitFor(() => {
          screen.findByTestId(
            `contract-updating-status-is-${ProgressStatus.IS_ERROR}`
          );
        });

        await act(async () => fireEvent.click(screen.getByTestId("update-grant-application")));

        await waitFor(() => {
          expect(
            screen.queryByTestId(
              `contract-updating-status-is-${ProgressStatus.IS_ERROR}`
            )
          ).not.toBeInTheDocument();
        }, { timeout: 15000 });

        await waitFor(() => {
          expect(
            screen.queryByTestId(
              `contract-updating-status-is-${ProgressStatus.IS_ERROR}`
            )
          ).not.toBeInTheDocument();
        }, { timeout: 15000 });
      });

      it("if indexing fails, resets indexing status when bulk update is retried", async () => {
        (updateApplicationStatuses as jest.Mock).mockResolvedValue({
          transactionBlockNumber: 100,
        });
        (waitForSubgraphSyncTo as jest.Mock)
          .mockRejectedValueOnce(new Error(":("))
          .mockReturnValue(
            new Promise(() => {
              /* do nothing.*/
            })
          );

        renderWithProvider(<TestUseBulkUpdateGrantApplicationComponent />);
        await act(async () => fireEvent.click(screen.getByTestId("update-grant-application")));

        // retry bulk update operation
        await waitFor(() => {
          screen.findByTestId(
            `indexing-status-is-${ProgressStatus.IS_ERROR}`
          );
        });
        await act(async () => fireEvent.click(screen.getByTestId("update-grant-application")));

        await waitFor(() => {
          expect(
            screen.queryByTestId(
              `indexing-status-is-${ProgressStatus.IS_ERROR}`
            )
          ).not.toBeInTheDocument();
        }, { timeout: 15000 });
      });
    });
  });
});

const TestUseBulkUpdateGrantApplicationComponent = () => {
  const {
    bulkUpdateGrantApplications,
    contractUpdatingStatus,
    indexingStatus,
  } = useBulkUpdateGrantApplications();

  const roundId = faker.finance.ethereumAddress();
  const applications = [makeApplication(), makeApplication()];
  const selectedApplications = [applications[0]];

  return (
    <div>
      <button
        onClick={() => {
          bulkUpdateGrantApplications({
            roundId,
            applications,
            selectedApplications,
          });
        }}
        data-testid="update-grant-application"
      >
        Bulk Update Grant Applications
      </button>

      <div
        data-testid={`contract-updating-status-is-${contractUpdatingStatus}`}
      />

      <div data-testid={`indexing-status-is-${indexingStatus}`} />
    </div>
  );
};

function renderWithProvider(ui: JSX.Element) {
  render(
    <BulkUpdateGrantApplicationProvider>
      {ui}
    </BulkUpdateGrantApplicationProvider>
  );
}

export { };
